import { NextRequest, NextResponse } from 'next/server';
import { mcpClientService } from '@/lib/services/mcpClientService';
import { geminiService } from '@/lib/services/gemini';
import { GeminiRequest, GeminiResponse } from '@/lib/types';

export async function POST(req: NextRequest) {
  try {
    const { promptName, arguments: args } = await req.json();
    if (!promptName) {
      return NextResponse.json({ success: false, error: 'promptName is required' }, { status: 400 });
    }

    // Ensure arg values are strings for MCP
    const stringArgs: Record<string, string> = Object.fromEntries(
      Object.entries((args as Record<string, unknown>) || {}).map(([k, v]) => [k, typeof v === 'string' ? v : JSON.stringify(v)])
    );

    // Optionally prime the MCP server: run dataset profiling first when data_path provided
    let profileResult: unknown = null;
    if (stringArgs.data_path) {
      const prof = await mcpClientService.callTool('business-intelligence', 'profile_dataset', {
        data_path: stringArgs.data_path
      });
      if (prof.success) profileResult = prof.data;
    }

    // Get prompt from BI MCP server
    const mcp = await mcpClientService.getPrompt('business-intelligence', promptName, stringArgs);
    if (!mcp.success) {
      return NextResponse.json({ success: false, error: mcp.error || 'MCP prompt failed' }, { status: 502 });
    }

    // Feed MCP output to Gemini to generate a user-facing narrative
    const ai = await geminiService.generateInsights({
      context: 'Business Intelligence Data Discovery and Profiling. Convert MCP prompt output into a high-signal markdown brief with sections: Overview, Findings, data quality, recommendations, and next steps.',
      data: {
        promptName,
        arguments: stringArgs,
        mcp_result: mcp.data,
        profile_result: profileResult
      } as Record<string, unknown>,
      task: 'business_summary',
      focusArea: 'data discovery and profiling'
    } as unknown as GeminiRequest);

    const md = formatGeminiBIMarkdown(ai as unknown as GeminiResponse);
    return NextResponse.json({ success: true, data: md, execution_time: mcp.execution_time });
  } catch (error) {
    console.error('Business Intelligence API Error:', error);
    return NextResponse.json({ success: false, error: 'Internal server error' }, { status: 500 });
  }
}

function formatGeminiBIMarkdown(ai: GeminiResponse) {
  const summary = ai?.summary || 'Analysis generated by Gemini.';
  const insights = Array.isArray(ai?.insights) ? ai.insights : [];
  const recommendations = Array.isArray(ai?.recommendations) ? ai.recommendations : [];
  const keyFindings = Array.isArray(ai?.keyFindings) ? ai.keyFindings : [];
  const nextSteps = Array.isArray(ai?.nextSteps) ? ai.nextSteps : [];

  return `# ðŸ“Š Data Discovery & Profiling

${summary}

## ðŸ”Ž Key Findings
${keyFindings.map((f: string) => `- ${f}`).join('\n')}

## ðŸ’¡ Insights
${insights.map((f: string) => `- ${f}`).join('\n')}

## âœ… Recommendations
${recommendations.map((f: string) => `- ${f}`).join('\n')}

## ðŸš€ Next Steps
${nextSteps.map((f: string) => `- ${f}`).join('\n')}
`;
}


